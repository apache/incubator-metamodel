/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
package org.apache.metamodel.jdbc;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertNotNull;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.SQLException;
import java.util.concurrent.atomic.AtomicInteger;

import org.apache.commons.dbcp.BasicDataSource;
import org.apache.metamodel.DataContext;
import org.apache.metamodel.UpdateScript;
import org.apache.metamodel.data.DataSet;
import org.apache.metamodel.insert.InsertInto;
import org.apache.metamodel.schema.Column;
import org.apache.metamodel.schema.ColumnType;
import org.apache.metamodel.schema.Table;
import org.apache.metamodel.update.RowUpdationBuilder;
import org.junit.After;
import org.junit.Before;
import org.junit.Test;

public class JdbcUpdateCallbackTest {

    /**
     * This test will only work with certain transaction isolation levels. Both levels
     * {@link Connection#TRANSACTION_REPEATABLE_READ} and {@link Connection#TRANSACTION_SERIALIZABLE} should work fine,
     * but lower levels will cause issues because of the concurrent reading of the "n" variable which is also being
     * concurrently updated.
     */
    private final int ISOLATION_LEVEL = java.sql.Connection.TRANSACTION_REPEATABLE_READ;

    BasicDataSource dataSource;
    JdbcDataContext dataContext;
    final String tableName = "counter_table";
    final String columnName = "n";

    AtomicInteger closeCount = new AtomicInteger();
    AtomicInteger prepareCount = new AtomicInteger();

    @Before
    public void init() throws Exception {
        DerbyTest.initDerbySettings();
        dataSource = new BasicDataSource();
        dataSource.setDriverClassName("org.apache.derby.jdbc.EmbeddedDriver");
        dataSource.setUrl("jdbc:derby:target/temp_derby;create=true");
        dataSource.setInitialSize(1);
        dataSource.setMaxActive(10);
        dataSource.setMaxWait(10000);
        dataSource.setMinEvictableIdleTimeMillis(1800000);
        dataSource.setMinIdle(0);
        dataSource.setMaxIdle(0);
        dataSource.setNumTestsPerEvictionRun(3);
        dataSource.setTimeBetweenEvictionRunsMillis(-1);
        dataSource.setDefaultTransactionIsolation(ISOLATION_LEVEL);

        dataContext = new JdbcDataContext(dataSource) {
            public Connection getConnection() {
                return new ConnectionWrapper(super.getConnection()) {
                    public PreparedStatement prepareStatement(String sql, int autoGeneratedKeys) throws SQLException {
                        prepareCount.incrementAndGet();
                        return new PreparedStatementWrapper(super.prepareStatement(sql, autoGeneratedKeys)) {
                            public void close() throws SQLException {
                                closeCount.incrementAndGet();
                                super.close();
                            }
                        };
                    }
                    public PreparedStatement prepareStatement(String sql) throws SQLException {
                        prepareCount.incrementAndGet();
                        return new PreparedStatementWrapper(super.prepareStatement(sql)) {
                            public void close() throws SQLException {
                                closeCount.incrementAndGet();
                                super.close();
                            }
                        };
                    }
                };
            }
        };

        dataContext.executeUpdate(callback -> {
            if (dataContext.getTableByQualifiedLabel(tableName) != null) {
                callback.dropTable(tableName).execute();
            }
            callback.createTable(dataContext.getDefaultSchema(), tableName).withColumn(columnName)
                    .ofType(ColumnType.INTEGER).execute();
        });
    }

    @After
    public void cleanup() throws SQLException {
        dataSource.close();
    }

    @Test
    public void testTransactionalUpdateScripts() throws Exception {
        final Table table = dataContext.getTableByQualifiedLabel(tableName);
        final Column col = table.getColumnByName(columnName);
        assertNotNull(col);

        // insert one record - this one record will be updated transactionally below
        dataContext.executeUpdate(new InsertInto(table).value(columnName, 0));

        final UpdateScript updateScript = callback -> {
            final int n = getCounterValue(callback.getDataContext(), table, col);
            callback.update(table).value(col, n + 1).execute();
        };

        final int threadCount = 2;
        final int iterationsPerThread = 5;

        final Thread[] threads = new Thread[threadCount];
        for (int i = 0; i < threads.length; i++) {
            threads[i] = new Thread() {
                @Override
                public void run() {
                    for (int j = 0; j < iterationsPerThread; j++) {
                        int retries = 10;
                        while (retries > 0) {
                            try {
                                dataContext.executeUpdate(updateScript);
                                retries = 0;
                            } catch (RolledBackUpdateException e) {
                                retries--;
                                if (retries == 0) {
                                    throw e;
                                }
                            }
                        }
                    }
                }
            };
        }
        for (Thread thread : threads) {
            thread.start();
        }
        for (Thread thread : threads) {
            thread.join();
        }

        assertEquals(threadCount * iterationsPerThread, getCounterValue(dataContext, table, col));
    }

    @Test
    public void testPreparedStatementCache() {
        prepareCount.set(0);
        closeCount.set(0);
        dataContext.executeUpdate((callback) -> {
            callback.insertInto(tableName).value(0, 1).execute();
            callback.insertInto(tableName).value(0, 2).execute();;
            assertEquals(1, prepareCount.get());
            assertEquals(0, closeCount.get());

            for(int i = 0; i < 10; i++) {
                RowUpdationBuilder builder = callback.update(tableName).value(0, 3).where(columnName).eq(2);
                for(int j = 0; j < i; j++) {
                    builder.where(columnName).eq(3);
                }
                builder.execute();
            }
            assertEquals(11, prepareCount.get());
            // cache size = 10 => 1 had to be kicked from the cache and closed.
            assertEquals(1, closeCount.get());
        });
        assertEquals(11, prepareCount.get());
        assertEquals(11, closeCount.get());
    }

    private int getCounterValue(DataContext dataContext, Table table, Column column) {
        final DataSet ds = dataContext.query().from(table).select(column).execute();
        try {
            ds.next();
            final Number n = (Number) ds.getRow().getValue(0);
            return n.intValue();
        } finally {
            ds.close();
        }
    }
}
